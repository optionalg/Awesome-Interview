1. I/O控制方式
 - 程序IO方式，是采用busy-waiting的方式，即CPU会采用轮询的方式来询问数据-------效果最差
 - 中断IO方式，是设备控制器当取出一个数据之后向CPU发送一个中断，然后CPU将数据从控制器中取到CPU寄存器，再然后转移到内存中。这种方式，CPU是以字节的方式来响应数据的。
 - DMA方式，是CPU通过向DMA控制器设定若干参数，然后DMA打开了一条内存到设备的通道，这样，设备（内存）中的数据可以不通过ＣＰＵl来进行数据交互。缺点是，DMA是多少设备就需要多少DMA，而且，DMA方式下，CPU的访问设备是以数据块为周期的。
 - IO通道方式，IO通道相当于一个简单的处理机，有自己的指令，也可以执行指令。指令存储在内存。IO通道相当于一条PCI总线，一条IO通道可以连接所有的设备控制器。然后CPU向IO通道发出指令，IO通道将会自动进行获取数据。另外，IO通道是以一组块为单位进行获取的。

2. 强迫性中断和自愿性中断 强迫性中断由随机事件引起而非程序员事先安排, `硬件故障中断`, `程序性中断`, `外部中断` 及 `输入/输出中断` 是强迫性中断. 

3. 进程退出时销毁该进程独立拥有的一系列资源，包括文件，网络，内存等等，但是共享内存是进程间通信方式的一种，不仅仅是该进程所独有的，若共享内存销毁后可能会影响其他进程

4. 检测死锁对系统资源的分配不加限制，只要有则可以进行分配，允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，反复检测各进程资源申请和分配情况，及时的检测出死锁的发生，并确定与死锁有关的进程和资源，然后通过解除死锁的措施，将已发生的死锁清除掉。检测死锁不是预防系统卷入死锁。

5. 处理死锁的方法:
 - 预防死锁: 这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较易实现的方法，已被广泛使用。
 - 避免死锁: 同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免死锁。
 - 检测死锁: 这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。
 - 解除死锁: 当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其继续运行。

> 上述的几种方法，防范程度逐渐减弱，但对应的是资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）


6. 设有m个资源，n个进程，每个进程要调用k个资源，一次只能调用一个，则: m>n(k-1) 即可

7. 进程上下文实际上是进程执行活动全过程的静态描述。

8. 执行系统调用也是可以中断的，只能说某些操作是不可以被中断的








