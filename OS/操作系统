1. I/O控制方式
 - 程序IO方式，是采用busy-waiting的方式，即CPU会采用轮询的方式来询问数据-------效果最差
 - 中断IO方式，是设备控制器当取出一个数据之后向CPU发送一个中断，然后CPU将数据从控制器中取到CPU寄存器，再然后转移到内存中。这种方式，CPU是以字节的方式来响应数据的。
 - DMA方式，是CPU通过向DMA控制器设定若干参数，然后DMA打开了一条内存到设备的通道，这样，设备（内存）中的数据可以不通过ＣＰＵl来进行数据交互。缺点是，DMA是多少设备就需要多少DMA，而且，DMA方式下，CPU的访问设备是以数据块为周期的。
 - IO通道方式，IO通道相当于一个简单的处理机，有自己的指令，也可以执行指令。指令存储在内存。IO通道相当于一条PCI总线，一条IO通道可以连接所有的设备控制器。然后CPU向IO通道发出指令，IO通道将会自动进行获取数据。另外，IO通道是以一组块为单位进行获取的。

2. 强迫性中断和自愿性中断 强迫性中断由随机事件引起而非程序员事先安排, `硬件故障中断`, `程序性中断`, `外部中断` 及 `输入/输出中断` 是强迫性中断. 

3. 进程退出时销毁该进程独立拥有的一系列资源，包括文件，网络，内存等等，但是共享内存是进程间通信方式的一种，不仅仅是该进程所独有的，若共享内存销毁后可能会影响其他进程

4. 检测死锁对系统资源的分配不加限制，只要有则可以进行分配，允许系统在运行过程中发生死锁，但可通过系统所设置的检测机构，反复检测各进程资源申请和分配情况，及时的检测出死锁的发生，并确定与死锁有关的进程和资源，然后通过解除死锁的措施，将已发生的死锁清除掉。检测死锁不是预防系统卷入死锁。

5. 处理死锁的方法:
 - 预防死锁: 这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较易实现的方法，已被广泛使用。
 - 避免死锁: 同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免死锁。
 - 检测死锁: 这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。
 - 解除死锁: 当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其继续运行。

> 上述的几种方法，防范程度逐渐减弱，但对应的是资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）


6. 设有m个资源，n个进程，每个进程要调用k个资源，一次只能调用一个，则: m>n(k-1) 即可

7. 进程上下文实际上是进程执行活动全过程的静态描述。

8. 执行系统调用也是可以中断的，只能说某些操作是不可以被中断的

9. 
 - 最先适应算法：依次判定后找到第一个满足要求的哈
 - 循环首次适应算法：每次基于上一次的位置寻找
 - 最佳适应算法：对空闲区按从小到大排序，第一个满足的就是啦
 - 最差适应算法：对空闲区按从大到小排序，第一个满足的就是啦
 - 固定式分区算法：是分区的

10. 管道是单向的、先进先出的，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读取数据。

11. 影响缺页中断次数和页面大小有关系，但并不只取决于页面大小，还和系统总内存容量等很多因素有关，当系统内存不足时，会发生页面交换，此时也会产生很多次缺页中断，但与页面大小就没有关系了。


12. 相比于单道程序设计（内存中仅有一道作业），多道程序设计按照一定的作业调度算法将作业队列中的作业调入内存，使他们共享 CPU 和各种资源，因此需要更大的内存以容纳超过一道的作业。

13. 处理机调度的层次
 - 高级调度: 高级调度又称长程调度或作业调度，它的调度对象是作业。其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。
 - 低级调度: 低级调度又称为进程调度或短程调度，其所调度的对象是进程（或内核级线程）。其主要功能是，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的 OS 中，都必须配置这级调度。
 - 中级调度: 中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。为此，应把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外状态（或挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂起在就绪队列上等待。中级调度实际上就是存储器管理中的对换功能。


14. 引起进程阻塞和唤醒的事件：
1、向系统请求共享资源失败。进程转变为阻塞状态。
2、等待某种操作完成。比如进程启动了I/O设备，必须等I/O操作完成后，进程才能继续。
3、新数据尚未到达。对于合作的进程，如果一个进程A需要先获得另一进程B提供的数据后，才能对该数据进程处理，只要数据尚未到达，进程A只能阻塞。当进程B提供数据后，便可以去唤醒进程A。
4、等待新任务到达，用于特定的系统进程。它们每当完成任务后，就把自己阻塞起来，等待新任务。


15. 通道解决并行性，缓冲解决速度差异

16. 挂起操作的原因:
挂起原语 `Suspend`，激活原语 `Active`
 - 终端用户的需要。当终端用户在自己的程序运行期间发现有可以问题，希望暂停自己的程序的运行，使之停止下来，以便用户研究其执行情况或对程序进行修改
 - 父进程请求。有时父进程希望挂起自己的某个子进程，一边考察和修改该子进程，或者协调各子进程间的活动
 - 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行
 - 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账

17. 多级队列和多级反馈队列
多级队列：该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。
多级队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。

多级反馈队列：1）设置多个就绪队列。在系统中设置多个就绪队列，并未每个队列赋予不同的优先级。第一个队列的优先级最高，第二个次之，其余的优先级逐个降低。该算法为不同的队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片就愈小。
2）每个队列都采用FCFS算法。3）按队列优先级调度。







